name: Test Resource Server

on:
  issue_comment:
    types: [created,edited]
permissions:
  issues: write
  
jobs:
  build:
    runs-on: ubuntu-latest
    env:
        GITHUB_TOKEN: ${{ secrets.TOKEN }}
    if: contains(github.event.comment.body, '/test_rs') && github.event.issue.pull_request != null && github.repository.permissions.${{ github.event.sender.login }} == 'write'
    steps:
    - name: check user access with mgs
      run: |      
        #!/bin/bash
        set -e  # exit immediately if a command exits with a non-zero status
        set -x  # enable debugging output

        # Extract the repository owner and name from the event payload
        REPO_OWNER=$(echo "${GITHUB_REPOSITORY}" | cut -d "/" -f 1)
        REPO_NAME=$(echo "${GITHUB_REPOSITORY}" | cut -d "/" -f 2)

        # Get the username of the user who created the comment
        SENDER=$(jq -r ".comment.user.login" "$GITHUB_EVENT_PATH")

        # Get the permissions of the user who created the comment
        PERMISSIONS=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/collaborators/$SENDER/permission" | jq -r ".permission")

        # Check if the user has write permission
        if [ "$PERMISSIONS" == "write" ]; then
          echo "User has write permission"
        else
          echo "User does not have write permission"
          pr_number=$(jq -r ".issue.number" "$GITHUB_EVENT_PATH")
          curl -s -H "Authorization: Bearer $GITHUB_TOKEN" -X POST -d "{\"body\":\"@$SENDER You are not authorized to trigger this workflow. Only users with write permission can trigger this workflow.\"}" "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/issues/$pr_number/comments"
        fi


      
    - name: check user access
      run: |
        #!/bin/bash
        set -e  # exit immediately if a command exits with a non-zero status
        set -x  # enable debugging output

        # Extract the repository owner and name from the event payload
        REPO_OWNER=$(echo "${GITHUB_REPOSITORY}" | cut -d "/" -f 1)
        REPO_NAME=$(echo "${GITHUB_REPOSITORY}" | cut -d "/" -f 2)

        # Get the username of the user who created the comment
        SENDER=$(jq -r ".comment.user.login" "$GITHUB_EVENT_PATH")

        # Get the permissions of the user who created the comment
        PERMISSIONS=$(curl -s -H "Authorization: Bearer ${{ env.GITHUB_TOKEN }} "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/collaborators/$SENDER/permission" | jq -r ".permission")

        # Check if the user has write permission
        if [ "$PERMISSIONS" == "write" ]; then
          echo "User has write permission"
        else
          echo "User does not have write permission"
        fi
        
    - name: Check if user has write access
      run: |
          # Get the owner and repository name
          OWNER=$(echo ${{ github.repository }} | cut -d/ -f1)
          REPO=$(echo ${{ github.repository }} | cut -d/ -f2)

          # Get the commenter's username
          SENDER=$(echo ${{ github.event.comment.user.login }})

          # Get a token with repo scope from the secrets
          TOKEN="${{ secrets.GITHUB_TOKEN }}"

          # Make a call to the API to check the user's permissions
          PERMS=$(curl -s -H "Authorization: token ${{ env.GITHUB_TOKEN }} "https://api.github.com/repos/$OWNER/$REPO/collaborators/$SENDER/permission")

          # Check if the user has write access
          if [[ $(echo $PERMS | jq -r '.permission') == "admin" || $(echo $PERMS | jq -r '.permission') == "write" ]]; then
            echo "User $SENDER has write access to $OWNER/$REPO"
          else
            echo "User $SENDER does not have write access to $OWNER/$REPO"
            exit 1
          fi
    
    - name: Get user permissions
      uses: octokit/request-action@v2.x
      id: permissions
      with:
        route: GET /repos/:owner/:repo/collaborators/:username/permission
        owner: ${{ github.event.repository.owner.login }}
        repo: ${{ github.event.repository.name }}
        username: ${{ github.event.sender.login }}

    - name: Print user permission level
      run: echo "User permission level is ${{ steps.permissions.outputs.data.permission }}"
  
    - uses: actions-cool/check-user-permission@v2
      id: check
      with:
        require: 'write'
        check-contributor: true

    - run: echo "user-permission = ${{ steps.check.outputs.user-permission }}"
    - run: echo "require-result = ${{ steps.check.outputs.require-result }}"
    - run: echo "check-result = ${{ steps.check.outputs.check-result }}"
        
    - name: Dump context
      run: echo '${{ toJSON(github.event) }}' | jq
      shell: bash
    - name: Dump context
      run: |
        echo ${{ github.event.sender.login }}
        echo "${{github.repository}}"
      shell: bash
      
    - name: Get Pull Request context
      id: extract_pr
      run: |        
        OWNER=$(curl -s -H "Authorization: Bearer ${{ env.GITHUB_TOKEN }}" https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.issue.number }}| jq -r '.head.repo.owner.login')
        REPO=$(curl -s -H "Authorization: Bearer ${{ env.GITHUB_TOKEN }}" https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.issue.number }}| jq -r '.head.repo.name')
        REF=$(curl -s -H "Authorization: Bearer ${{ env.GITHUB_TOKEN }}" https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.issue.number }}| jq -r '.head.ref')
        echo "OWNER=${OWNER}" >> $GITHUB_ENV
        echo "REPO=${REPO}" >> $GITHUB_ENV
        echo "REF=${REF}" >> $GITHUB_ENV       
        

    - name: Checkout PR API
      uses: actions/checkout@v3
      with:
        repository: ${{ env.OWNER }}/${{ env.REPO }}
        ref: ${{ env.REF }}       
        
    - name: List Files
      run: |
          pwd
          ls -a
          ls .github/workflows
          git branch
          echo $GITHUB_REPOSITORY
          echo $GITHUB_WORKSPACE
          env
    

          
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.24.8'
      id: install
      
    - name: Configure kubectl
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets.KUBE_CONFIG }}" | base64 --decode > $HOME/.kube/config
      
    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
         token: ${{ github.token }}


    - name: configure resource server
      run: |
        cp -r K8s-deployment/Charts/resource-server/example-secrets/* K8s-deployment/Charts/resource-server/
        echo "${{ secrets.RS_RESOURCE_VALUES }}" > K8s-deployment/Charts/resource-server/resource-values.yaml
        echo -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}"  > K8s-deployment/Charts/resource-server/secrets/AWS_SECRET_ACCESS_KEY
        echo -n "${{ secrets.AWS_ACCESS_KEY_ID }}" > K8s-deployment/Charts/resource-server/secrets/AWS_ACCESS_KEY_ID
        echo "${{ secrets.RS_CONFIG }}" | base64 --decode > K8s-deployment/Charts/resource-server/secrets/config.json
        echo "${{ secrets.RS_TEST_CONFIG }}" | base64 --decode > rs_test_config.json
        
    - name: deploy
      run: |
        cd K8s-deployment/Charts/resource-server/
        kubectl create ns rs-test
        kubectl create configmap rs-env --from-env-file=./secrets/.rs.env -n rs-test
        kubectl create secret generic rs-s3-env --from-file=./secrets/AWS_ACCESS_KEY_ID --from-file=./secrets/AWS_SECRET_ACCESS_KEY -n rs-test
        kubectl create secret generic rs-config --from-file=./secrets/config.json -n rs-test
        helm install resource-server "../resource-server" -f values.yaml -f resource-values.yaml -n rs-test
        
    - name: Install Testkube
      run: |
        wget -qO - https://repo.testkube.io/key.pub | sudo apt-key add - && echo "deb https://repo.testkube.io/linux linux main" | sudo tee -a /etc/apt/sources.list && sudo apt-get update && sudo apt-get install -y testkube
        kubectl testkube get test
        pwd
        
    - name: Test Execute
      run: |
        testkube create executor --name pytest-executor-gh --namespace testkube --types pytest-executor-gh1/test-gh-1 --executor-type container --image docker.io/pranav0/testkube-executor-pytest:1.0.9 --command "pytest" --command "test_rs.py" --command "--html=/share/test/reports/rs_report.html" --feature artifacts --content-type string
        testkube create test --name rs-test --namespace testkube --file  rs_test_config.json --type pytest-executor-gh1/test-gh-1 --artifact-storage-class-name azuredisk-storage-class --artifact-volume-mount-path /share --artifact-dir test/reports
        testkube run test rs-test --download-artifacts
        ls -a
        
    - name: Download Test reports
      run: |
        sleep 2m
        execution_output=$(tk get execution --test rs-test --output json)
        result_id=$(echo $execution_output | jq -r '.results[0].id')
        kubectl testkube download artifacts $result_id
        
    - name: Upload test reports
      uses: actions/upload-artifact@v3
      with:
        name: Test Reports
        path: artifacts/
        
    - name: Delete deployment
      run: |
       kubectl delete ns rs-test 
       testkube  delete executor pytest-executor-gh
       testkube  delete test rs-test
    
